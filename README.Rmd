---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# IReNA

<!-- badges: start -->
<!-- badges: end -->

IReNA (Integrated Regulatory Network Analysis) is to reconstruct regulatory networks through integrating scRNA-seq and ATAC-seq data. IReNA contains four main part to get regulatory network: 

Part1: Analyze scRNA-seq or bulk RNA-seq data to get basic regulatory relationships

Part2: Use RcisTarget to refine regulatory relaionships

Part3: Analyze ATAC-seq data to refine regulatory relationships

Part4: Regultory network analysis. 

If you **have ATAC-seq data**, use **part 3** to refine regulatory relationships. If you **don't have ATAC-seq data**, use **part 2** to refine regulatory relaionships

## Citation
If you use IReNA package, please cite the following Science paper: https://science.sciencemag.org/content/370/6519/eabb8598.

## Workflow
![workflow](Readme figure/Workflow.jpg)

## Installation

First, install a few Bioconductor dependencies that aren't automatically installed:
```r
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(c('Rsamtools', 'ChIPseeker', 'monocle',
                       'RcisTarget', 'RCy3'))
```

Second, install IReNA from GitHub:
```r
install.packages("devtools")
devtools::install_github("jiang-junyao/IReNA")
```
## ATAC-seq data preprocessing
If you use ATAC-seq data to refine regulatory relaionships (part3), you need to preprocess ATAC-seq raw data(fastq) to get bam, peak and footprints. So we provide [ATAC-seq analysis pipline](https://github.com/jiang-junyao/ATAC-seq-pipline) for user to preprocess ATAC-seq data. The object of this pipline is to get bam file of each sample, peaks file of all samples and footprints of all samples as IReNA input. If you are familiar with ATAC-seq data analysis, you can do it as you like.

## IReNA Input
Before run IReNA, you need to prepare 7 files which will be used through the analysis process, where bam file, Peak file, footprints file can be generated by [ATAC-seq analysis pipline](https://github.com/jiang-junyao/ATAC-seq-pipline) to generate these files. If you **only use scRNA-seq data or bulk RNA-seq data**, you just need to input **raw counts of scRNA-seq data, or Seurat object, or bulk RNA-seq expression profile(3), and motif database(6)**.

### 1.Bam file of each sample
Bam file that can be generated by [samtools](http://www.htslib.org/). Note that you need to de-duplicate and sort these BAM files through rmdup and sorted function of samtools respectively.

### 2.Peak file of all samples
You can use MACS2 to call peaks of each sample, and use XXX() function in IReNA to merge these peaks.

### 3.Raw counts of scRNA-seq data, or Seurat object, or bulk RNA-seq expression profile. 
IReNA provides function to load raw counts of scRNA-seq data, and return seurat object. If your data is [10X format](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices), set parameter datatype = 0. If your data is normal counts format(txt suffix), set parameter dayatype =1. If you have your own seurat object, you can skip load_counts, and use your own seurat object as 'seurat_object'.
```r
### load 10X counts
seurat_object <- load_counts('10X_data/sample1/', datatype = 0)
### load normal counts
seurat_object <- load_counts('test_data.txt',datatype = 1)
### read seurat object
seurat_object <- readRDS('seurat_object.rds')
```
If you use bulk RNA-seq data to get basic regulatory relationships, just input your bulk RNA-seq expression matrix as 'expression_profile', Use the same code as the scRNA-seq data to continue the analysis.

### 4.Footprints file
Footprints file can be generated by [HINT](http://www.regulatory-genomics.org/hint/introduction/) or [dnase2tf](https://github.com/jiang-junyao/dnase2tf) (I recommand HINT, because dnase2tf is not user friendly). The name of first column should be 'chr', name of second column should be 'start', name of third column should be 'end' and the fourth column should be pvalue or other score to evalute footprints.

### 5.Reference genome of your species
Reference genome needs to be the same as that used for mapping, you can download it from [UCSC](https://hgdownload.soe.ucsc.edu/downloads.html).

### 6.Motif database
IReNA contains DNA motif datasets for four species (Homo sapiens, Mus musculus, Zebrafish and Chicken) derived from [TRANSFAC 201803](https://genexplain.com/transfac/). Following codes are used to call  the motif dataset from TRANSFAC or  user-defined motif dataset which should have the same format as these from TRANSFAC database.
```r
library(IReNA)
###call Mus musculus motif database
motif1 <- Tranfac201803_Mm_MotifTFsF
###call Homo sapiens motif database
motif1 <- Tranfac201803_Hs_MotifTFsF
###call Zebrafish motif database
motif1 <- Tranfac201803_Zf_MotifTFsF
###call Chicken motif database
motif1 <- Tranfac201803_Ch_MotifTFsF
```

### 7.Position weight matrix
IReNA contain position weight matrix from [TRANSFAC201803](https://genexplain.com/transfac/), you can use the following code to call it, or you can use your own position weight matrix.
```r
PWM <- Tranfac201803_MotifPWM
```
## Test data
Test data can be download from ...

## Example
IReNA contains four main part to get regulatory network: (1) Analyze scRNA-seq or bulk RNA-seq data to get basic regulatory relationships (2) Use RcisTarget to refine regulatory relaionships (3) Analyze ATAC-seq data to refine regulatory relationships (4) Regultory network analysis. If you **have ATAC-seq data**, use **part 2** to refine regulatory relationships. If you **don't have ATAC-seq data**, use **part 3** to refine regulatory relaionships

### Part1: Analyze scRNA-seq or bulk RNA-seq data to get basic regulatory relationships
IReNA supports two input format: (i)path of raw counts, you can input path of raw counts and use function in GReNA to load data and convert it to Seurat object; (ii)Seurat object. after you upload the data, IReNA can calculate pseudotime according to R package monocle and add it to the metadata of Seurat object.

Our seurat object only contains differentially expressed genes, so we set the parameter 'DEG' in add_pseudotime_DEG_filter() function as FALSE, if you seurat object contain all genes, please set this parameter as TRUE. In paraell, our seurat object have been normalized, so we set the parameter 'normlize1' in add_pseudotime_DEG_filter() function as FALSE, if your seurat object only contains raw counts, please set this parameter as TRUE.
```r
###Read seurat_object
seurat_object <- readRDS('seurat_object.rds')
###calculate the pseudotime and return monocle object
monocle_object <- get_pseudotime(seurat_object,show_trajecotry = TRUE)
###Add pseudotime to the Seurat object
seurat_with_time <- add_pseudotime_DEG_filter(seurat_object, monocle_object,DEG = FALSE,normlize1 = FALSE)
```
Then, cells are divided into 50 bins across pseudotime. The bin is removed if all genes in this bin have no expression. Gene is filtered if fold change < 0.1 (setting by the parameter FC). Then, genes will be clustered through K-means algorithm (K is setting by the parameter K1).
```
###Get expression profiles ordered by pseudotime
expression_profile <- get_SmoothByBin_PseudotimeExp(seurat_with_time, Spec1='Hs')
###Filter noise and logFC in expression profile
expression_profile_filter <- fileter_expression_profile(expression_profile, FC=0.01)
###K-means clustering
clustering <- clustering_Kmeans(expression_profile_filter, K1=4)
```
Visualize your clustering result through heatmap
```r
col1 <- c('#67C1E3','#EF9951','#00BFC4','#AEC7E8','#C067A9','#E56145','#2F4F4F')
###plot kmeans pheatmap
plot_kmeans_pheatmap(clustering, ModuleColor1 = col1,Range1=c(-1.5,1.5),NumRowBlank1=30)
```
![workflow](Readme figure/Kmeans_plot.png)

Adding Ensmble ID of the genes in the first column, then calculate the correlation of the gene pair and select gene pairs which contain at least one gene in transcription factors database and have absolute value of correlation larger than 0.6(setting by the parameter correlatio_filter).
```r
###Add Ensembl ID as the first column of clustering results
Kmeans_clustering_ENS <- add_ENSID(clustering, Spec1='Hs')
###Caculate the correlation
regulatory_relaionships <- get_cor(Kmeans_clustering_ENS, 'Hs', motif = motif1)
```
### Part2: Use RcisTarget to refine regulatory relaionships (without ATAC-seq data)
For users who do not have ATAC-seq data, IReNA provides filter_regulation function (Based on RcisTarget) to refine regulation relaionships. Before run this function, you need to download Gene-motif rankings database from https://resources.aertslab.org/cistarget/, and set the Rankingspath1 as the path of downloaded Gene-motif rankings database. Due to the limitations of RcisTarget, this function currently only supports three species (Hs, Mm and Fly). **So if the species of your data is not included, and you don't have ATAC-seq data, you can use unrefined regulatory relaionships to perform part4 analysis directly.**
```r
###Refine regulatory relaionships
Rankingspath1 <- 'hg19-500bp-upstream-7species.mc9nr1.feather'
filtered_regulatory_relationships <- filter_regulation(regulatory_relationships, 'Hs', Rankingspath1)
```

### Part3: Analyze ATAC-seq data to refine regulatory relationships (have ATAC-seq data)
For users who have ATAC-seq data, IReNA provides several functions to calculate related transcription factors of footprints with high FOS to refine regulatory relationships. First, we load the footprints which generated by HINT to R, and use tag-count score > 80th percentile as threshold to identify footprints with high quality. Then, we merge footprints whose distance is less than 4 and get sequence from each footprints based on reference genome through function get_merged_fasta(). Reference genome should be fasta/fa format, and you can download it from https://hgdownload.soe.ucsc.edu/downloads.html#alpaca or other genome database website.
```r
###Identify footprints with high quality
footprints <- read.table('footprints.bed',sep='\t',header = T)
footprints_80th <- footprints[footprints$V5 > quantile(footprints$V5, 0.8),]
footprints_80th <- footprints_80th[,c(1,2,3,5)]
###merge footprints whose distance is less than 4
fastadir <- 'Genome/GRCm38Chr.fasta' 
merged_fasta <- get_merged_fasta(footprints_80th,fastadir)
write.table(merged_fasta,'merged_footprints.fasta',row.names=F,quote=F)
```
In this step, because [fimo](https://meme-suite.org/meme/doc/fimo.html) software only have linux version, and it takes too long to implement the corresponding function on Windows, we generate a shell script to run Fimo software in shell. If you are familiar with linux system and Fimo, you can write your own commands as you like.

Before run find_motifs() function, you should set the following four parameters: (1) fimodir: path of fimo software, if you have added fimo to the environment variable, just set this argument as 'fimo'. (2) outputdir1: output path of shell script. (3) outputdir: output path of fimo result. (4) motifdir: path of motif file, you can download it from [TRANSFAC201803](https://genexplain.com/transfac/). (5) sequencedir: path of sequence which generated by get_merged_fasta(). Please note that, at the end of outputdir and sequencedir must contain / symbol.


```r
fimodir <- 'fimo'
outputdir1 <- 'D:/GIBH/IReNA2 R package/IReNA2/ATAC/fimo/'
outputdir <- '/public/home/user/fimo/output/'
motifdir <- '/public/home/user/fimo/Mememotif/'
sequencedir <- '/public/home/user/fimo/merged_footprints.fasta'
find_motifs(motif1,step=20,fimodir, outputdir1, outputdir, motifdir, sequencedir)
```
Then you need to use [winscp](https://winscp.net/eng/download.php) or other related software to transfer script in outputdir1 to Linux system, and run following commands (If you make analysis in linux system, ignore transfer part).
```
### run the following commands in the shell
cd /public/home/user/fimo/
sh ./fimo_all.sh
```
After get the result of Fimo, you can use [winscp](https://winscp.net/eng/download.php) or other related software to transfer fimo result files from linux to windos(If you use R in linux, please ignore this part). Then, we combine these Fimo consequence according to motif and motif Position weight matrix, and Dir2 folder should only contain fimo result files. Next, we load the peaks file and overlap differential peaks and motif footprints through overlap_footprints_peaks() function
```r
###Combine all footprints of motifs
PWM <- Tranfac201803_MotifPWM ###choose PWM
Dir2 <- 'D:/GIBH/IReNA2 R package/IReNA2/ATAC/fimo/'
combied <- combine_footprints(motif1, PWM, Dir2)
peaks <- read.delim('D:\\IReNA\\ATAC\\Peaks\\peaks_merged.txt')
overlapped <- overlap_footprints_peaks(combied,peaks)
```
However, the running time of overlap_footprints() is too long, so it's highly recommanded to use bedtools to do overlap in linux system. If you want to use bedtools to do overlap, you need to output 'combined_footprints' dataframe, and transfer it to shell.(If you make analysis in linux system, ignore transfer part)
```r
### output combined_footprints
write.table(combined_footprints,'combied.txt',quote = F,row.names = F,col.names = F,sep = '\t')
### run the following commands in the shell
bedtools intersect -a combied_footprints.txt -b peaks_merged.bed -wa -wb > overlappd.txt
```
Next, we intergrate bioconductor package [ChIPseeker](https://bioconductor.org/packages/release/bioc/vignettes/ChIPseeker/inst/doc/ChIPseeker.html) to get footprint-related genes. Before we run get_related_genes(), we need to specify TxDb, which can be download from: http://bioconductor.org/packages/release/BiocViews.html#___TxDb. Kmeans_clustering_ENS used here was obtained in part1.
```r
### If you make overlap by bedtools, read 'overlapped.txt' to R
overlapped <- read.table('overlapped.txt')
###get footprint-related genes
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
list1 <- get_related_genes(overlapped,txdb = txdb,motif=Tranfac201803_Mm_MotifTFsF,Species = 'Mm')
###Get candidate genes/TFs-related peaks
list2 <- get_related_peaks(list1,Kmeans_clustering_ENS)
### output filtered footprints
write.table(list2[[1]],'filter_footprints.bed', quote = F, row.names = F, col.names = F, sep = '\t')
```

Use samtools or bedtools to extract footprints realated regions in bam to reduce analysis time of next step. So you first need to transfer 'filter_footprints.bed' to shell, and run the following codes. After extraction done, transfer 'sample1_filter.bam' 'sample2_filter.bam' 'sample3_filter.bam' to windows system.(If you make analysis in linux system, ignore transfer part)
```r
### Use bedtools
bedtools intersect -a  sample1_rmdup.bam  -b filtered_footprint.bed  > sample1_filter.bam
bedtools intersect -a  sample2_rmdup.bam  -b filtered_footprint.bed  > sample2_filter.bam
bedtools intersect -a  sample3_rmdup.bam  -b filtered_footprint.bed  > sample3_filter.bam
### Use samtools
samtools view -hb -L filtered_footprint.bed sample1_rmdup.bam > sample1_filter.bam
samtools view -hb -L filtered_footprint.bed sample2_rmdup.bam > sample2_filter.bam
samtools view -hb -L filtered_footprint.bed sample3_rmdup.bam > sample3_filter.bam
```

In this step, we count the cuts of each position in footrprints by wig_track(), and use these cuts to calculate the FOS of footprints to identify enriched TFs which determine the regulatory relationship. regulatory_relationships used here was calculated in part1.
```r
bamfilepath1 <- 'sample1_filter.bam'
bamfilepath2 <- 'sample2_filter.bam'
bamfilepath3 <- 'sample3_filter.bam'
cuts1 <- wig_track(bamfilepath = bamfilepath1,bedfile = list2[[1]])
cuts2 <- wig_track(bamfilepath = bamfilepath2,bedfile = list2[[1]])
cuts3 <- wig_track(bamfilepath = bamfilepath3,bedfile = list2[[1]])
wig_list <- list(cuts1,cuts2,cuts3)
potential_regulation <- Footprints_FOS(wig_list,list2[[2]])
### Calculate correaltion of each gene pairs
filtered_regulatory_relationships <- regulatory_relationships[regulatory_relationships$TF %in% potential_regulation$TF & regulatory_relationships$Target %in% potential_regulation$Target,]
```

### Part4: Regulatory network analysis

Run get_Enriched_TFs() to get enriched transcription factors(parameter TFFdrThr1 is the cutoff to filter enriched TFs), this step will generate a list which contain the following 5 dataframes: (1)“Cor_TFs.txt”: list of expressed TFs in the gene networks. (2)“Cor_EnTFs.txt”: list of TFs which significantly regulate gene modules (or enriched TFs). (3)“FOSF_RegMTF_Cor_EnTFs.txt”: regulatory pairs in which the source gene is enriched TF. (4)“FOSF_RegMTF_Cor_EnTFs.txt”: regulatory pairs in which both source gene and target gene are enriched TFs. (5)“FOSF_RegMTF_Cor_EnTFs.txt”: regulatory pairs only including regulations within each module but not those between modules, in this step
```r
TFs_list <- get_Enriched_TFs(filtered_regulatory_relationships, Kmeans_clustering_ENS, TFFdrThr1=2)
```
Identify enriched TFs which significantly regulate gene modules, and remove regulatory pairs which do not contain enriched TFs. The filtered regulatory pairs are used to plot regulatory networks.
```r
TFs_list <- get_regulation_of_TFs_to_modules(TFs_list, Thr=10)
###Get regulatory networks which consist of enriched TFs
tf_network <- get_partial_regulations(TFs_list)
###display the network through igraph package
plot_network(tf_network, layout='circle', type='TF')
```
Calculate the significance of regulations between any two modules using hypergeometric test, and use significant intramodular regulation relationship to construct intramodular regulatory networks. The significance is setting through the parameter ‘ModuleThr1’.
```r
###Generate intermodular regulatory networks
intramodular_network <- merge_Module_Regulations(TFs_list, Kmeans_clustering_ENS, ModuleThr1=0.05)
###display the network through igraph package
plot_network(intramodular_network, layout='grid', type='module',legend = FALSE)
```
It is strongly recommended to use Cytoscape(downloading link: https://cytoscape.org/download.html) to display the regulatory networks. We provide a function that can provide different Cytoscape styles. You need to intall and open Cytoscape before running the function.
```r
###optional: display the network in cytoscape, open cytoscape before running this function
initiate_cy(tf_network, layout1='degree-circle', type='TF')
initiate_cy(intramodule_network, layout1='grid', type='module')
```
