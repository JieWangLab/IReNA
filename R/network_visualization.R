#' Function to visualize regulatory network
#' @description This function integrate R package igraph to visualize consequence of regulatory network analysis
#' @param TFs_list TFs_list generated by \code{\link{network_analysis}}
#' @param enrichment Enrichment analysis results of genes in each module, generated by \code{\link{enrichment_analysis}}. If it is not NULL, when plotting the Intramodular Network, the functions enriched by each module will be plotted in the diagram
#' @param layout the layout to display the network, options: 'grid','sphere','circle','random'
#' @param group.cols colors for group in network
#' @param title.name the name of the title
#' @param vertex.size vertex size
#' @param type network type, 'TF' indicate TFs network, 'module' indicate intramodular network
#' @param vertex.label.color ertex label color
#' @param edge.label.color edge label color
#' @param legend logic, indicating whether to show the legend
#' @param vertex.label.cex The label size of vertex
#' @param vertex.label.family vertex label family
#' @param frame.color frame.color
#' @param arrow.size arrow size
#' @param arrow.width arrow width
#' @param edge.with edge width
#' @param edge.curved edge curvature
#' @param edge.color edge color
#' @param vertex.label.degree The position of the label in relation to the vertex (This parameter is valid only when the enrichment does not equal null)
#' @param vertex.label.dist Distance between the label and the vertex (This parameter is valid only when the enrichment does not equal null)
#' @import ggplot2
#' @importFrom igraph E
#' @importFrom igraph V
#' @importFrom igraph layout_on_grid
#' @importFrom igraph layout_on_sphere
#' @importFrom igraph layout_in_circle
#' @importFrom igraph layout_randomly
#' @export
#' @return figure
#' @examples#' Kmeans_clustering <- add_ENSID(Kmeans_clustering, Spec1 = "Hs")
#' cor0.6 <- get_cor(Kmeans_clustering, "Hs", 0.9, start_column=3)
#' TFs_list <- network_analysis(regulatory_relationships,Kmeans_cluster_Ens)
#' plot_network(TFs_list,layout = 'circle',type = 'TF')
#' plot_network(TFs_list,layout = 'random',type = 'module',vertex.size = 25,vertex.label.cex = 1.1,edge.with = 2,arrow.size = 0.5)
#' #enrichment <- enrich_module(Kmeans_cluster_Ens, org.Hs.eg.db, 'KEGG')
#' #plot_network(TFs_list,enrichment,layout = 'random',type = 'module',vertex.size = 25,vertex.label.cex = 1.1,edge.with = 2,arrow.size = 0.5,vertex.label.family = 'Times')
plot_network <- function(TFs_list, enrichment = NULL,layout, group.cols = NULL, title.name = NULL, vertex.size = 10, type = "TF", vertex.label.color = 'black', edge.label.color = 'black'
                         ,legend = TRUE, vertex.label.cex = 0.6, vertex.label.family = 'ArialMT', frame.color = 'white'
                         , arrow.size = 0.2, arrow.width = 0.5, edge.with = 1.8, edge.curved = 0, edge.color = 'grey',
                         vertex.label.degree = 0.35, vertex.label.dist = -6) {
  if (is.null(group.cols)) {
    col1 <- c('#67C1E3','#EF9951','#00BFC4','#AEC7E8','#C067A9','#E56145','#2F4F4F')
  } else {
    col1 <- group.cols
  }
  if (type == "TF") {
    vertex.label.dist <- 0
    vertex.label.degree <- 0
    network <- TFs_list[["TF_network"]]
    tfs <- network[, c("TFSymbol", "TFGroup")]
    target <- network[, c("TargetSymbol", "TargetGroup")]
    colnames(target) <- c("TFSymbol", "TFGroup")
    nodes <- rbind(tfs, target)
    edges <- network[, c("TFSymbol", "TargetSymbol", "Regulation", "Correlation")]
  } else if (type == "module") {
    tf_network <- TFs_list[["TF_network"]]
    tf_max <- c()
    for (i in levels(as.factor(tf_network$TFGroup))) {
      module <- tf_network[tf_network$TFGroup==i,]
      table1 <- as.data.frame(table(module$TFSymbol))
      group_tf <- table1[table1$Freq == max(table1$Freq),]
      tf <- as.character(group_tf[,1])
      tf_max <- c(tf_max, tf)
    }
    network <- TFs_list[["intramodular_network"]]
    tfs <- network[, c("TFGroup", "TFGroup")]
    target <- network[, c("TargetGroup", "TargetGroup")]
    colnames(target) <- c("TFGroup", "TFGroup")
    nodes <- rbind(tfs, target)
    edges <- network[, c("TFGroup", "TargetGroup", "Regulation", "Correlation")]
    if (is.null(enrichment)) {
      vertex.label.dist <- 0
      vertex.label.degree <- 0
    for (i in 1:nrow(edges)) {
      name1 <- tf_max[as.integer(edges[i,1])]
      name2 <- tf_max[as.integer(edges[i,2])]
      edges[i,1] <- paste0('Module ',edges[i,1],'\n',name1)
      edges[i,2] <- paste0('Module ',edges[i,2],'\n',name2)
    }
    for (i in 1:nrow(nodes)) {
      name1 <- tf_max[as.integer(nodes[i,1])]
      name2 <- tf_max[as.integer(nodes[i,2])]
      nodes[i,1] <- paste0('Module ',nodes[i,1],'\n',name1)
      nodes[i,2] <- paste0('Module ',nodes[i,2])}
     } else{
      for (i in 1:nrow(edges)) {
        name1 <- tf_max[as.integer(edges[i,1])]
        name2 <- tf_max[as.integer(edges[i,2])]
        edges[i,1] <- paste0('Module ',edges[i,1],'\n','enriched factor: ',name1,'\n','enriched function:','\n',enrichment[enrichment$module == edges[i,1],][1,2])
        edges[i,2] <- paste0('Module ',edges[i,2],'\n','enriched factor: ',name2,'\n','enriched function:','\n',enrichment[enrichment$module == edges[i,2],][1,2])
      }
      for (i in 1:nrow(nodes)) {
        name1 <- tf_max[as.integer(nodes[i,1])]
        name2 <- tf_max[as.integer(nodes[i,2])]
        nodes[i,1] <- paste0('Module ',nodes[i,1],'\n','enriched factor: ',name1,'\n','enriched function:','\n',enrichment[enrichment$module == nodes[i,1],][1,2])
        nodes[i,2] <- paste0('Module ',nodes[i,2])
        }
       }
    }
  colnames(nodes) <- c("name", "type")
  nodes <- nodes[!duplicated(nodes$name), ]
  colnames(edges) <- c("from", "to", "type", "weight")
  g <- igraph::graph_from_data_frame(edges, vertices = nodes, directed = TRUE)
  if (layout == "grid") {
    layout1 <- igraph::layout_on_grid(g)
  } else if (layout == "sphere") {
    layout1 <- igraph::layout_on_sphere(g)
  } else if (layout == "circle") {
    layout1 <- igraph::layout_in_circle(g)
  } else if (layout == "random") {
    layout1 <- igraph::layout_randomly(g)
  } else {
    print("please input correct layout name")
  }
  edge.start <- igraph::ends(g, es=igraph::E(g), names=FALSE)
  igraph::E(g)$arrow.size <- arrow.size
  igraph::E(g)$arrow.width <- arrow.width
  igraph::E(g)$label.color <- edge.label.color
  igraph::E(g)$color<- edge.color
  igraph::E(g)$width<- edge.with

  if (type == "TF") {
    igraph::V(g)$color <- col1[nodes$type]
  } else if (type == "module") {
  igraph::V(g)$color <- col1[1:length(nodes$type)]
  }
  igraph::V(g)$size<- vertex.size
  igraph::V(g)$label.color <- vertex.label.color
  igraph::V(g)$frame.color <- frame.color

  plot(g, layout = layout1, edge.curved = edge.curved, vertex.label.cex = vertex.label.cex, layout = layout1,
       , vertex.shape='circle', vertex.label.family = vertex.label.family, vertex.label.dist = vertex.label.dist, vertex.label.degree = vertex.label.degree)
  if (legend == TRUE) {
    if (type == "TF") {
      legend(x = 1.5, y = 1.3, paste0('Module',levels(factor(igraph::V(g)$type))), pch = 21, col = "#777777", pt.bg = col1)
    } else if (type == "module") {
      legend(x = 1.5, y = 1.3, levels(factor(igraph::V(g)$type)), pch = 21, col = "#777777", pt.bg = col1)
    }
  }
  if (!is.null(title.name)) {
    text(0,1.5,title.name, cex = 1.1)
  }
}

#' initiating the cytoscape
#' @description Initiate Cytoscape to visualize regulatory network
#' @param TFs_list TFs_list generated by \code{\link{network_analysis}}
#' @param colour vector, indicating colors for border of each node
#' @param type network type, 'TF' indicate TFs network, 'module' indicate intramodular network
#' @param layout1 the layout to display the network, options: "degree-circle", "attributes-layout", "kamada-kawai", "force-directed", "cose", "hierarchical", "attribute-circle", "stacked-node-layout", "circular", "grid"
#' @return Cytoscape visualization
#' @importFrom RCy3 cytoscapePing
#' @importFrom RCy3 cytoscapeVersionInfo
#' @importFrom RCy3 createNetworkFromDataFrames
#' @importFrom RCy3 mapVisualProperty
#' @importFrom RCy3 createVisualStyle
#' @importFrom RCy3 setVisualStyle
#' @importFrom RCy3 layoutNetwork
#' @export
#'
#' @examples \dontrun{
#' initiate_cy(TFs_list, layout1='degree-circle', type='TF')
#' initiate_cy(TFs_list, layout1='grid', type='module')
#' }
initiate_cy <- function(TFs_list, colour = NULL, type = "TF", layout1 = "degree-circle") {
  RCy3::cytoscapePing()
  RCy3::cytoscapeVersionInfo()
  if (type == "TF") {
    network <- TFs_list[["TF_network"]]
    tfs <- network[, c("TFSymbol", "TFGroup")]
    target <- network[, c("TargetSymbol", "TargetGroup")]
    colnames(target) <- c("TFSymbol", "TFGroup")
    nodes <- rbind(tfs, target)
    edges <- network[, c("TFSymbol", "TargetSymbol", "Regulation", "Correlation")]
  } else if (type == "module") {
    network <- TFs_list[["intramodular_network"]]
    tfs <- network[, c("TFGroup", "TFGroup")]
    target <- network[, c("TargetGroup", "TargetGroup")]
    colnames(target) <- c("TFGroup", "TFGroup")
    nodes <- rbind(tfs, target)
    edges <- network[, c("TFGroup", "TargetGroup", "Regulation", "Correlation")]
    edges$TFGroup <- as.character(edges$TFGroup)
    edges$TargetGroup <- as.character(edges$TargetGroup)
    nodes$TFGroup <- as.character(nodes$TFGroup)
  }
  colnames(nodes) <- c("id", "group")
  nodes <- nodes[!duplicated(nodes$id), ]
  colnames(edges) <- c("source", "target", "interaction", "weight")
  RCy3::createNetworkFromDataFrames(nodes, edges, title = "my first network", collection = "DataFrame Example")
  style.name <- "network1"
  if (is.null(colour)) {
    col1 <- c('#67C1E3','#EF9951','#00BFC4','#AEC7E8','#C067A9','#E56145','#2F4F4F')
  } else {
    col1 <- colour
  }
  defaults <- list(
    NODE_SHAPE = "BioPAX",
    NODE_SIZE = 120,
    EDGE_TRANSPARENCY = 120,
    NODE_LABEL_FONT_SIZE = 29,
    NODE_FILL_COLOR = "White"
  )
  nodeLabels <- RCy3::mapVisualProperty("node label", "id", "p")
  nodeborder <- RCy3::mapVisualProperty(
    "Node Border Paint", "group", "d", levels(as.factor(network$TFGroup)),
    col1
  )
  arrowShapes <- RCy3::mapVisualProperty("Edge Target Arrow Shape", "interaction", "d", levels(as.factor(network$Regulation)), c("Arrow", "T", "None"))
  edgeWidth <- RCy3::mapVisualProperty("edge width", "weight", "p")
  nodeFills <- RCy3::mapVisualProperty("Node Fill Color", "group", "p")
  RCy3::createVisualStyle(style.name, defaults, list(nodeLabels, nodeborder, arrowShapes, edgeWidth, nodeFills))
  RCy3::setVisualStyle(style.name)
  RCy3::layoutNetwork(layout1)
}
