
#' This function first merge and extend footprint regions, and then integrate R package ChIPseeker to get footprint-related genes
#'
#' @param footprints footprints file, generated by overlap_footprints_peaks() or intersect function of bedtools
#' @param motif motif file, you can choose our bulit-in motif database of 'mus musculus', 'homo sapiens', 'zebrafish' and 'chicken' by 'motif = Tranfac201803_Mm_MotifTFsF', 'motif = Tranfac201803_Hs_MotifTFsF', 'motif = Tranfac201803_Zf_MotifTFsF', 'motif = Tranfac201803_Ch_MotifTFsF' respectively, or you can upload your own motif data base, but the formata use be the same as our built-in motif database.
#' @param Species character, indicating the species of data which is used to choose annodb when annotate peak.
#' @param txdb 	TxDb object contained transcript-related features of a particular genome. Bioconductor provides several package that containing TxDb object of model organisms with multiple commonly used genome version, for instance TxDb.Hsapiens.UCSC.hg38.knownGene, TxDb.Hsapiens.UCSC.hg19.knownGene for human genome hg38 and hg19, TxDb.Mmusculus.UCSC.mm10.knownGene and TxDb.Mmusculus.UCSC.mm9.knownGene for mouse genome mm10 and mm9, etc.
#' @param tssRegion Region Range of TSS
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @importFrom ChIPseeker annotatePeak
#' @return return a list, first element is bed format datafrmae, second element is annotated footprints dataframe
#' @export
#'
#' @examples
get_related_genes <- function(footprints, motif, Species, txdb, tssRegion = c(-3000, 3000)) {
  footprintslist <- merge_extent_footprints(footprints, motif)
  merged_footprints <- footprintslist[[2]]
  if (Species == "Hs") {
    annodb <- "org.Hs.eg.db"
  } else if (Species == "Mm") {
    annodb <- "org.Mm.eg.db"
  } else if (Species == "Zf") {
    annodb <- "org.Dr.eg.db"
  } else if (Species == "Ch") {
    annodb <- "org.Gg.eg.db"
  }
  reference_GRange <- GenomicRanges::GRanges(seqnames = merged_footprints$V1, IRanges::IRanges(start = as.numeric(merged_footprints$V2), end = as.numeric(merged_footprints$V3)), strand = merged_footprints$V4)
  peakAnno <- ChIPseeker::annotatePeak(reference_GRange,
    tssRegion = tssRegion,
    TxDb = txdb, annoDb = annodb
  )
  region <- peakAnno@anno@elementMetadata$annotation
  gene <- peakAnno@anno@elementMetadata$ENSEMBL
  start1 <- peakAnno@anno@ranges@start
  merged_footprints2 <- merged_footprints[merged_footprints$V2 %in% start1, ]
  region2 <- c()
  for (i in region) {
    region3 <- strsplit(i, "\\(")[[1]][1]
    region4 <- strsplit(region3, " ")[[1]]
    if (length(region4) > 1) {
      region5 <- region3
    } else {
      region5 <- region4[1]
    }
    region2 <- c(region2, region5)
  }
  merged_footprints2$gene <- gene
  merged_footprints2$region <- region2
  merged_footprints2 <- merged_footprints2[, c(9, 8, 1:7)]
  colnames(merged_footprints2) <- c(paste0("V", 1:9))
  footprintslist[[2]] <- merged_footprints2
  return(footprintslist)
}

#' Inner function to merge and extent footprints
#'
#' @param file1 footprints
#' @param motif motif file
#' @return return extented footprints

merge_extent_footprints <- function(file1, motif) {
  con1 <- file1
  con2 <- motif
  con3 <- con2[, c(1, 5)]
  col1 <- c()
  acc2 <- c()
  col2 <- c()
  hash1 <- list()
  for (i in 1:nrow(con1)) {
    var1 <- paste(con1[i, ][1]$V1, con1[i, ][2]$V2, con1[i, ][3]$V3, con1[i, ][4]$V4, sep = "\t")
    acc1 <- con1$V7
    if (acc1[i] %in% con3[, 1] == TRUE) {
      var12 <- paste(acc1[i], con3[con3[, 1] == acc1[i], ][2], sep = ";")
    }
    if (is.null(hash1[var1]) == FALSE) {
      hash1[[var1]] <- c(hash1[[var1]], var12)
    } else {
      hash1[var1] <- var12
    }
  }
  name1 <- names(hash1)
  name2 <- sort(name1)
  for (i in name2) {
    key21 <- strsplit(i, "\t")[[1]]
    num1 <- as.integer((as.numeric(key21[2]) + as.numeric(key21[3])) / 2)
    size1 <- as.numeric(key21[3]) - as.numeric(key21[2]) + 1
    num11 <- num1 - (size1 * 5)
    num12 <- num1 + (size1 * 5)
    var2 <- paste(hash1[[i]], collapse = "|")
    out1 <- paste(key21[1], num11, num12, sep = "\t")
    out2 <- paste(key21[1], key21[2], key21[3], key21[4], num11, num12, var2, sep = "\t")
    col1 <- c(col1, out1)
    col2 <- c(col2, out2)
  }
  col3 <- as.data.frame(col1)
  col4 <- as.data.frame(col2)
  col3 <- split_dataframe(col3, sep = "\t")
  col4 <- split_dataframe(col4, sep = "\t")
  list1 <- list(col3, col4)
  return(list1)
}
