#' Calculate FOS of footprints
#' @description Calculate the FOS(footprints occupancy score) to identify enriched
#' transcriptions factor, and use these transcription factors to identify significant
#' regulatory relationships
#' @param Wig_list list object, where each element is the \link{wig_track} result
#' of each sample.
#' @param Candid If you follow our our pipline, this parameter should be the
#' second element of the list that generated by get_peaks_genes()
#' @param FOS_threshold numeric, indicating the threshold of footprint occupancy
#' score to identify significant footprints.
#' @param trans_wig logcial, if you use dnase_wig_tracks_both2.py to get wig_list,
#' please set trans_wig parameter as TRUE.
#'
#' @return return related transcription factors of footprints with FOS above FOS_threshold
#' @export
#'
#' @examples load(system.file("extdata", "Candid.rda", package = "IReNA"))
#' load(system.file("extdata", "wig_list.rda", package = "IReNA"))
#' regulatory_relationships <- Footprints_FOS(wig_list, Candid)
Footprints_FOS <- function(Wig_list, Candid, FOS_threshold = 1, trans_wig = FALSE) {
  if (trans_wig == TRUE) {
    Wig_list2 <- Trans_WigToMultirows(Wig_list)
  } else {
    Wig_list2 <- Wig_list
  }
  cutsp2_list <- Add_size_of_motif(Wig_list2, Candid)
  cutsp2_FOS <- Cal_Footprints_FOS(cutsp2_list, FlankFold1 = 3)
  FOS1 <- Combine_Footprints_FOS(cutsp2_FOS)
  FOS2 <- Filter_Footprints(FOS1,FOS_threshold)
  FOSF <- get_potential_regulation(FOS2)
  FOSF_RegM <- Merge_same_pairs(FOSF)
  return(FOSF_RegM)
}



Trans_WigToMultirows <- function(Wig_list) {
  list1 <- list()
  for (i in 1:length(Wig_list)) {
    wig <- Trans_WigToMultirows2(as.data.frame(Wig_list[[i]]))
    list1[[i]] <- wig
  }
  return(list1)
}


Trans_WigToMultirows2 <- function(b) {
  rownum <- c()
  col1 <- c()
  for (i in 1:nrow(b)) {
    if (!b[i, ] %in% c(as.character(0:20)) | !b[i, ] %in% 0:20) {
      rownum <- c(rownum, i)
    }
  }
  for (i in 1:length(rownum)) {
    if (i == length(rownum)) {
      acc1 <- b[(rownum[i] + 1):nrow(b), ]
    } else {
      acc1 <- b[(rownum[i] + 1):(rownum[i + 1] - 1), ]
    }
    acc11 <- paste(acc1, collapse = "\t")
    acc2 <- strsplit(b[rownum[i], ], "\t")[[1]]
    acc21 <- strsplit(acc2[2], "=")[[1]][2]
    acc22 <- as.numeric(strsplit(acc2[3], "=")[[1]][2]) - 1
    acc23 <- acc22 + length(acc1)
    acc3 <- paste(acc21, acc22, acc23, acc11, "\t")
    col1 <- c(col1, acc3)
  }
  col1 <- as.data.frame(col1)
}



Add_size_of_motif <- function(cutsp_list, Candid) {
  list1 <- list()
  con2 <- Candid
  con2$V2 <- as.numeric(con2$V2)
  con2$V3 <- as.numeric(con2$V3)
  con2$V5 <- as.numeric(con2$V5)
  con2$V6 <- as.numeric(con2$V6)
  for (i in 1:length(cutsp_list)) {
    con3 <- cutsp_list[[i]]
    var11 <- c()
    var12 <- c()
    col1 <- c()
    for (k in 1:nrow(con3)) {
      var2 <- con3[k, ]
      var3 <- strsplit(var2, "\t")
      var31 <- var3[[1]][1:3]
      var32 <- var3[[1]][4:length(var3[[1]])]
      var311 <- paste0(var31[1:length(var31)], collapse = "\t")
      var321 <- paste0(var32[1:length(var32)], collapse = ",")
      var11 <- c(var11, var311)
      var12 <- c(var12, var321)
    }
    var1 <- as.data.frame(matrix(c(var11, var12), ncol = 2))
    for (j in 1:nrow(con2)) {
      var21 <- paste0(as.character(con2[j, ][c(1, 5, 6)]), collapse = "\t")
      size1 <- con2[j, ][3] - con2[j, ][2] + 1
      if (var21 %in% var1$V1) {
        col11 <- paste(con2[j, ][ncol(con2)], con2[j, ][4], size1, con2[j, ][1],
                       con2[j, ][2], con2[j, ][3], var1[var1$V1 == var21, ]$V2[1],
                       sep = "\t")
        col1 <- c(col1, col11)
      }
    }
    col2 <- as.data.frame(col1)
    col2 <- split_dataframe(col2)
    list1[[i]] <- col2
  }
  return(list1)
}


Cal_Footprints_FOS <- function(cutsp2_list, FlankFold1 = 3) {
  list1 <- list()
  for (i in 1:length(cutsp2_list)) {
    FP <- cutsp2_list[[i]]
    FOS <- Cal_Footprints_FOS2(FP, FlankFold1 = FlankFold1)
    list1[[i]] <- FOS
  }
  return(list1)
}


Cal_Footprints_FOS2 <- function(FP1, FlankFold1 = 3) {
  FP2 <- apply(FP1, 1, function(X1) {
    MotifSize1 <- as.numeric(X1[3])
    WidthL1 <- floor(MotifSize1 / 2)
    WidthR1 <- MotifSize1 - WidthL1
    WidthL2 <- floor(MotifSize1 * (2 * FlankFold1 + 1) / 2)
    WidthR2 <- MotifSize1 * (2 * FlankFold1 + 1) - WidthL2
    Insertion1 <- strsplit(X1[7], ",")[[1]]
    Midpoint1 <- floor(length(Insertion1) / 2)
    Insertion2 <- as.numeric(Insertion1[c((Midpoint1 - WidthL2 + 1):(Midpoint1 + WidthR2))])

    L1 <- sum(Insertion2[1:(WidthL2 - WidthL1)]) / FlankFold1
    M1 <- sum(Insertion2[(WidthL2 - WidthL1 + 1):(WidthL2 + WidthR1)])
    R1 <- sum(Insertion2[(WidthL2 + WidthR1 + 1):length(Insertion2)]) / FlankFold1
    FOS1 <- min(-log2((M1 + 1) / (L1 + 1)), -log2((M1 + 1) / (R1 + 1)))
    return(c(X1[1:6], as.numeric(FOS1)))
  })

  return(t(FP2))
}



Combine_Footprints_FOS <- function(FOS_list) {
  for (i in 1:length(FOS_list)) {
    FOS1 <- FOS_list[[i]]
    if (i == 1) {
      FOS2 <- FOS1
    } else {
      FOS2 <- cbind(FOS2, FOS1[, ncol(FOS1)])
    }
  }
  colnames(FOS2)[1:6] <- c("Motif", "Target", "MotifSize", "Chr", "Start", "End")
  return(FOS2)
}


Filter_Footprints <- function(FOS1, FOS_cutoff) {
  mFOS1 <- apply(FOS1, 1, function(x1) {
    x2 <- as.numeric(x1[7:length(x1)])
    x3 <- max(x2)
    return(x3)
  })
  FOS2 <- cbind(FOS1, mFOS1)
  colnames(FOS2)[ncol(FOS2)] <- "MaxFOS"
  FOS3 <- FOS2[FOS2[, "MaxFOS"] > FOS_cutoff, ]
  print(nrow(FOS2))
  print(nrow(FOS3))
  return(FOS3)
}



get_potential_regulation <- function(FOSF) {
  con1 <- FOSF
  col1 <- c()
  title1 <- paste("TF", "\t", "Motif", "\t", "Target", "\t", "TypeChrStartEndFOS")
  col1 <- c(title1, col1)
  for (i in 1:nrow(con1)) {
    acc11 <- strsplit(as.character(con1[i, ][1]), "\\|")[[1]]
    acc12 <- strsplit(as.character(con1[i, ][2]), ";")[[1]]
    acc121 <- c()
    for (j in 1:length(acc12)) {
      acc122 <- strsplit(acc12[j], "\\|")[[1]]
      acc1222 <- strsplit(acc122[1], ",")[[1]]
      var122 <- paste(acc122[2], con1[i, ][5], con1[i, ][6],
        con1[i, ][ncol(con1)],
        sep = ","
      )
      for (k in 1:length(acc1222)) {
        acc121 <- c(acc121, paste(acc1222[k], var122, sep = "\t"))
      }
    }
    for (j in 1:length(acc11)) {
      acc112 <- strsplit(acc11[j], ";")[[1]]
      for (k in 2:length(acc112)) {
        for (n in 1:length(acc121)) {
          var1 <- paste(acc112[k], acc112[1], acc121[n], sep = "\t")
          col1 <- c(col1, var1)
        }
      }
    }
  }
  col2 <- as.data.frame(col1)
  col2 <- split_dataframe(col2)
  colnames(col2) <- col2[1, ]
  col2 <- col2[-1, ]
  return(col2)
}


Merge_same_pairs <- function(FOSF_Reg) {
  con1 <- FOSF_Reg
  hash1 <- list()
  for (i in 1:nrow(con1)) {
    var1 <- paste(as.character(con1[i, ][c(1, 3)]), collapse = "\t")
    var2 <- paste(as.character(con1[i, ][c(2, 4)]), collapse = ",")
    if (is.null(hash1[var1]) == FALSE) {
      hash1[[var1]] <- c(hash1[[var1]], var2)
    } else {
      hash1[var1] <- var2
    }
  }
  name1 <- names(hash1)
  name1 <- sort(name1)
  col1 <- c(paste("TF", "Target", "MotifTypeChrStartEndFOS", sep = "\t"))
  for (i in 1:length(name1)) {
    acc1 <- paste(unlist(hash1[name1[i]]), collapse = ";")
    var1 <- paste(name1[i], acc1, sep = "\t")
    col1 <- c(col1, var1)
  }
  col2 <- as.data.frame(col1)
  col2 <- split_dataframe(col2)
  colnames(col2) <- col2[1, ]
  col2 <- col2[-1, ]
  return(col2)
}



Merge_TFs_genes <- function(FOSF_RegM) {
  con1 <- FOSF_RegM
  hash1 <- list()
  hash2 <- list()
  for (i in 1:nrow(con1)) {
    var1 <- con1[i, ][2:3]
    var2 <- con1[i, ][c(1, 3)]
    gene1 <- as.character(con1[i, ][1])
    gene2 <- as.character(con1[i, ][2])
    if (is.null(hash1[gene1]) == FALSE) {
      hash1[[gene1]] <- c(hash1[[gene1]], var1)
    } else {
      hash1[gene1] <- var1
    }
    if (is.null(hash2[gene2]) == FALSE) {
      hash2[[gene2]] <- c(hash2[[gene2]], var2)
    } else {
      hash2[gene2] <- var2
    }
  }
  col1 <- c()
  col2 <- c()
  col1 <- c(paste("TF", "Target", "MotifTypeChrStartEndFOS", sep = "\t"), col1)
  col2 <- c(paste("Target", "TF", "MotifTypeChrStartEndFOS", sep = "\t"), col2)
  for (i in 1:2) {
    if (i == 1) {
      hash3 <- hash1
    } else {
      hash3 <- hash2
    }
    name1 <- names(hash3)
    name1 <- sort(name1)
    col3 <- c()
    for (j in 1:length(name1)) {
      num <- seq(1, length(hash3[[name1[j]]]), by = 2)
      acc1 <- paste(unlist(hash3[[name1[j]]][num]), collapse = "|")
      acc2 <- paste(unlist(hash3[[name1[j]]][num + 1]), collapse = "|")
      var1 <- paste(name1[j], acc1, acc2, sep = "\t")
      col3 <- c(col3, var1)
    }
    if (i == 1) {
      col1 <- c(col1, col3)
    } else {
      col2 <- c(col2, col3)
    }
  }
  col1 <- as.data.frame(col1)
  col2 <- as.data.frame(col2)
  col1 <- split_dataframe(col1)
  col2 <- split_dataframe(col2)
  colnames(col1) <- col1[1, ]
  colnames(col2) <- col2[1, ]
  col1 <- col1[-1, ]
  col2 <- col2[-1, ]
  list1 <- list(col1, col2)
  return(list1)
}


#' Calculate correlation of each gene pair, and remove genes that are below the
#' threshold and are not transcription factors
#'
#' @param Kmeans_result Kmeans result, column names should be ENSEMBL ID
#' @param motif motif file, you can choose our bulit-in motif database of
#' 'mus musculus', 'homo sapiens', 'zebrafish' and 'chicken' by 'motif = Tranfac201803_Mm_MotifTFsF',
#' 'motif = Tranfac201803_Hs_MotifTFsF', 'motif = Tranfac201803_Zf_MotifTFsF',
#' 'motif = Tranfac201803_Ch_MotifTFsF' respectively, or you can upload your own motif data base, but the formata use be the same as our built-in motif database.
#' @param correlation_filter numeric, indicating correlation threshold
#' @param start_column numeric, indicating the start column of expression value,
#' defalut is 4
#' @import dplyr
#' @return return a table contain transcription factor with correlation >
#' correlation_filter and correlation < -correlation_filter
#' @export
#'
#' @examples load(system.file("extdata", "test_clustering.rda", package = "IReNA"))
#' correlation <- get_cor(test_clustering, Tranfac201803_Hs_MotifTFsF, 0.7, start_column=3)

get_cor <- function(Kmeans_result, motif, correlation_filter, start_column=4) {
  print("get correlation for gene pairs")
  a <- Kmeans_result
  b <- motif
  motifgene <- c()
  for (i in 1:nrow(b)) {
    gene1 <- strsplit(b[i,5],';')[[1]]
    motifgene <- c(motifgene,gene1)
  }
  Exp1 <- cor(t(a[start_column:ncol(a)]))
  col1 <- matrix(c("TF", "TFSymbol", "Target", "TargetSymbol", "Correlation"), nrow = 1)
  newdata <- subset(Exp1 > correlation_filter | Exp1 < -correlation_filter)
  for (i in 1:nrow(Exp1)) {
    if (rownames(Exp1)[i] %in% motifgene) {
      acc2 <- Exp1[i, ][newdata[i, ]]
      for (j in 1:length(acc2)) {
        if (rownames(Exp1)[i] != names(acc2)[j]) {
          if (names(acc2)[j] %in% motifgene) {
            var2 <- c(names(acc2)[j], a[names(acc2)[j], ]$Symbol, rownames(Exp1)[i],
                      a[rownames(Exp1)[i], ]$Symbol, acc2[j])
            col1 <- rbind(col1, var2)
          }
          var1 <- c(rownames(Exp1)[i], a[rownames(Exp1)[i], ]$Symbol, names(acc2)[j],
                    a[names(acc2)[j], ]$Symbol, acc2[j])
          col1 <- rbind(col1, var1)
        }
      }
    }
  }
  col1 <- as.data.frame(col1)
  colnames(col1) <- col1[1, ]
  col1 <- col1[-1, ]
  var1 <- col1
  con2 <- b
  con3 <- a
  TFGroup <- con3[match(var1$TFSymbol, con3$Symbol), ]$KmeansGroup
  TargetGroup <- con3[match(var1$TargetSymbol, con3$Symbol), ]$KmeansGroup
  var1$TFGroup <- TFGroup
  var1$TargetGroup <- TargetGroup
  col1 <- var1[, c("TF", "TFSymbol", "TFGroup", "Target", "TargetSymbol",
                   "TargetGroup", "Correlation")]
  col1 <- col1[!duplicated(col1),]
  regulation_self1 <- data.frame(rownames(a)[1]
                                 ,a[1,1],a[1,2],
                                 rownames(a)[1],
                                 a[1,1],a[1,2],
                                 1)
  colnames(regulation_self1) <- c("TF", "TFSymbol", "TFGroup", "Target", "TargetSymbol",
                                  "TargetGroup", "Correlation")
  for (i in 2:nrow(a)) {
    regulation_self2 <- data.frame(rownames(a)[i]
                                   ,a[i,1],a[i,2],
                                   rownames(a)[i],
                                   a[i,1],a[i,2],
                                   1)
    colnames(regulation_self2) <- c("TF", "TFSymbol", "TFGroup", "Target", "TargetSymbol",
                                    "TargetGroup", "Correlation")
    regulation_self1 <- rbind(regulation_self1,regulation_self2)
  }
  regulation_self1 <- regulation_self1[regulation_self1$TF %in% motifgene,]
  col1 <- rbind(col1,regulation_self1)
  return(col1)
}

#' filter regulatory relationships based on footprints with high FOS
#' @description overlap footprints information with regulatory relationships
#' @param FOS footprints information, generated in \link{Footprints_FOS}
#' @param regulary_relationships generated in \link{get_cor}
#'
#' @return overlapped regulatory relationships
#' @export
#'
#' @examples
filter_ATAC <- function(FOS,regulary_relationships){
  pair1 <- paste(FOS[,1],FOS[,2])
  pair2 <- paste(regulary_relationships[,1],regulary_relationships[,4])
  filtered <- regulary_relationships[pair2 %in% pair1,]
  return(filtered)
}
